[gd_resource type="Resource" load_steps=2 format=2]

[sub_resource type="GDScript" id=1]
script/source = "extends Resource
class_name Envelope

enum Waveform {
	custom, square, pulse25, pulse10, triangle, sawtooth, sine, noise, flat,
	falloff, falloff_linear, echo, hit_sustain,
	arpeggio, arpeggio_chord, tremolo, slide, bass
}

export(Waveform) var shape := Waveform.flat
export var name := \"envelope\"

export var default_length := 32
export var default_value := 0.0
export var max_value := 16.0
export var min_value := 0.0

export var attack := true
export var release := true
export var loop := false
export var loop_in := 0
export var loop_out := 32

export var data := []
export var is_edited := false

var value := 0.0
var next := 0.0
var position := 0
var is_releasing := false
var completed := false


func _init():
	data = [0.0]
	reset()


func _to_string()->String:
	var text := name+\"\\n\"
	text += \"current shape:\"+str(shape)+\"\\n\"
	text += \"loop:\"+str(loop)+\"; \"
	text += \"loop_in:\"+str(loop_in)+\"; \"
	text += \"loop_out:\"+str(loop_out)+\"\\n\"
	return text


func generate_preset(index:int, length:int):
	is_edited=false
	data.clear()
	data.resize(length)
	shape=index
	loop = true
	match index:
		Waveform.square: data = Generator.array_square(data.size(), min_value, max_value, 0.5, true)
		Waveform.pulse25: data = Generator.array_square(data.size(), min_value, max_value, 0.25, true)
		Waveform.pulse10: data = Generator.array_square(data.size(), min_value, max_value, 0.1, true)
		Waveform.triangle:
			min_value = -max_value
			data = Generator.array_triangle(data.size(), min_value, max_value, true)
		Waveform.sawtooth: data = Generator.array_sawtooth(data.size(), min_value, max_value, true)
		Waveform.flat: data = Generator.array_flat(data.size(),default_value, true)
		Waveform.sine:
			min_value = -max_value
			data = Generator.array_sine(data.size(), min_value, max_value, true)
		Waveform.noise: data = Generator.array_noise(data.size(), min_value, max_value, true)
		Waveform.falloff:
			data = Generator.array_falloff(data.size(), max_value,true)
			loop = false
		Waveform.falloff_linear:
			data = Generator.array_falloff_linear(data.size(), max_value, true)
			loop = false
		Waveform.hit_sustain:
			data = [10,12,15,12,10,9,8,7,6,5,4,3,2,1,0]
			max_value = 15
			min_value = 0
			loop = true
			loop_in = 2
			loop_out = 2
		Waveform.arpeggio:
			data = [0,12,-12]
			max_value = 12
			min_value = -12
			loop = true
			loop_in = 0
			loop_out = 2
		Waveform.arpeggio_chord:
			data = [0,5,10]
			max_value = 12
			min_value = -12
			loop = true
			loop_in = 0
			loop_out = 2
		Waveform.tremolo:
			data = [0,1,0,-1]
			max_value = 12
			min_value = -12
			loop = true
			loop_in = 0
			loop_out = 3
		Waveform.slide:
			data = [0, -4, -8, -12, -16, -20, -24, -28, -32]
			max_value = 32
			min_value = -32
			loop = false
		Waveform.bass:
			data = [12,0,-8,-16,-24,-32]
			max_value = 32
			min_value = -32
			loop = false
		_: data = Generator.array_flat(data.size(),default_value, true)


func tick_forward():
	if not attack:
		if position < loop_in:
			position = loop_in

	position+=1

	if loop:
		if position > loop_out:
			if release:
				if is_releasing:
					pass
				else:
					position = loop_in
			else:
				if is_releasing:
					completed = true
				position = loop_in

	if at_end():
		completed = true
		position = data.size()
		next = 0.0
		return
	else:
		next = data[position]


func at_end()->bool:
	return(position >= data.size())

#Needs to be called to \"apply\" the next value to the current. Used by
#RCC tracks to prevent clicking when applying the envelope
func commit_value():
	value = next


func current()->float:
	return value


func normalized()->float:
	return value/max_value


func reset():
	completed = false
	is_releasing = false
	if attack:
		position = 0
	else:
		position = loop_in
	if not data.empty():
		value = data[position]
		next = data[position]
	else:
		value = 1.0
		next = 1.0


func length()->int:
	return data.size()


func effective_length()->int:
	var loop_length:= loop_out-loop_in
	var effective_in:= 0
	var effective_out:= data.size()
	if loop:
		if not attack: effective_in=loop_in
		if not release: effective_out=loop_out+1
	print(name, effective_out-effective_in)
	return effective_out-effective_in


func effective_loop_in()->int:
	if attack:
		return loop_in
	else:
		return 0


func effective_loop_out()->int:
	if attack:
		return loop_out
	else:
		return loop_out - loop_in


func set_length(value:int):
	data.resize(value)
	for n in range(data.size()):
		if not data[n]:
			data[n]=0.0


func clip_min():
	if not data.empty():
		for n in data.size():
			if data[n]<min_value: data[n]=min_value


func clip_max():
	if not data.empty():
		for n in data.size():
			if data[n]>max_value: data[n]=max_value
"

[resource]
resource_name = "Noise"
script = SubResource( 1 )
shape = 8
name = "envelope"
default_length = 16
default_value = 0.0
max_value = 3.0
min_value = 0.0
attack = false
release = false
loop = false
loop_in = 0
loop_out = 16
data = [  ]
is_edited = false
